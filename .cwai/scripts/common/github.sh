#!/bin/bash

#######################################
# GitHub Helper Functions
#
# This file contains common GitHub-related functions for issue management,
# label operations, and GitHub CLI interactions.
#
# Follows Google Bash Style Guide: https://google.github.io/styleguide/shellguide.html
#######################################

# Prevent multiple sourcing
[[ -n "${_GITHUB_SH_SOURCED:-}" ]] && return 0
readonly _GITHUB_SH_SOURCED=1

if ! command -v log_info >/dev/null 2>&1; then
  echo "log_info function is not available, please import log.sh before github.sh" >&2
  exit 1
fi

if ! command -v generate_hex_color >/dev/null 2>&1; then
  echo "generate_hex_color function is not available, please import strings.sh before github.sh" >&2
  exit 1
fi

# Create label if it doesn't exist
label_ensure() {
  local label_name="$1"
  local label_color="${2:-}"
  local label_description="${3:-}"

  if [ -z "$label_color" ]; then
    label_color=$(generate_hex_color)
  fi

  if gh label list --json name --jq ".[].name" | grep -q "^${label_name}$"; then
    return 0
  fi

  log_info "ðŸ·ï¸ Creating label: $label_name"
  if [[ -n "$label_description" ]]; then
    gh label create "$label_name" --color "$label_color" --description "$label_description" >/dev/null 2>&1
  else
    gh label create "$label_name" --color "$label_color" >/dev/null 2>&1
  fi
}

# Ensure multiple labels exist, optionally format as CLI args
labels_ensure() {
  local labels="$1"
  local as_args="$2"

  if [[ -z "$labels" ]]; then
    return 0
  fi

  local labels_spaced="${labels//,/ }"
  local label_array=($labels_spaced)
  local output_args=()

  for label in "${label_array[@]}"; do
    label=$(echo "$label" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    if [[ -n "$label" && ! "$label" =~ ^- ]]; then
      label_ensure "$label"

      if [[ "$as_args" == "--as-args" ]]; then
        output_args+=(--label "$label")
      fi
    fi
  done

  if [[ "$as_args" == "--as-args" ]]; then
    printf "%s " "${output_args[@]}"
  fi
}

# Add comment to existing issue
issue_add_comment() {
  local issue_number="$1"
  local comment_body="$2"

  if ! gh issue view "$issue_number" >/dev/null 2>&1; then
    log_error "Issue #$issue_number does not exist or is not accessible"
    return 1
  fi

  log_info "ðŸ’¬ Adding comment to issue #${issue_number}"
  gh issue comment "$issue_number" --body "$comment_body" 2>&1 >/dev/null
}

# Add labels to issue (create labels if needed)
issue_add_labels() {
  local issue_number="$1"
  local labels="$2"

  if ! issue_exists "$issue_number" >/dev/null 2>&1; then
    log_error "Issue #$issue_number does not exist or is not accessible"
    return 1
  fi

  IFS=',' read -ra LABELS <<<"$labels"
  for label in "${LABELS[@]}"; do
    label=$(echo "$label" | xargs)
    if [[ "$label" == -* ]]; then
      gh issue edit "$issue_number" --remove-label "${label#-}" 1>&2 >/dev/null
    elif [[ -n "$label" ]]; then
      label_ensure "$label"
      gh issue edit "$issue_number" --add-label "$label" 1>&2 >/dev/null
    fi
  done
}

# Create issue with title, body, and labels
issue_create() {
  local title="$1" body="$2" labels="$3"
  local label_args=()

  label_ensure "task" "0e8a16" "Task item"
  label_ensure "auto-generated" "bfd4f2" "Automatically generated by script"

  if [ -n "$labels" ]; then
    eval "label_args+=($(labels_ensure "$labels" "--as-args"))"
  fi

  label_args+=(--label "task" --label "auto-generated")

  log_info "ðŸ·ï¸ Creating GitHub issue: $title"
  local issue_url
  issue_url=$(gh issue create --title "$title" --body "$body" "${label_args[@]}")

  local issue_number
  issue_number=$(echo "$issue_url" | grep -o '[0-9]\+$')
  echo "$issue_number"
}

# Create parent-child relationship between issues
# TODO: This should be a Github Project feature - haven't figured it out how it works yet
issue_ensure_parent() {
  log_warn "Assigning Parent Issue is done only as comments until we understand Github Project API"
  local child_issue="$1"
  local parent_issue="$2"

  if ! gh issue view "$parent_issue" >/dev/null 2>&1; then
    log_warn "Parent issue #$parent_issue does not exist; skipping assigning parent"
    return 0
  fi

  gh issue comment "$child_issue" --body "**Parent Task:** #$parent_issue

This task is a subtask of #$parent_issue.

---
*Relationship added via create-issue.sh script*" >/dev/null 2>&1

  gh issue comment "$parent_issue" --body "**Subtask Created:** #$child_issue

New subtask created and linked to this parent task.

---
*Relationship added via create-issue.sh script*" >/dev/null 2>&1

  log_info "âœ… Parent relationship established between #$child_issue and #$parent_issue"
}

# Add issue to project (currently disabled)
# TODO: This should be a Github Project feature - haven't figured it out how it works yet
issue_ensure_project() {
  log_warn "Assigning Github Project is curently disabled until we understand how to implement"
  return 0

  local issue_number="$1"
  local project_name="$2"

  [ -z "$issue_number" ] && log_error "No issue mentioned to add to project."
  [ -z "$project_name" ] && log_error "No project assign issue to"

  local owner_args=()
  local project_owner="$3"

  if [ -n "$project_owner" ]; then
    owner_args+=(--owner "$project_owner")
  fi

  local project_number
  if [ -n "$project_name" ]; then
    project_number=$(_get_project_number "$project_name" "$project_owner")
  fi

  if [ -z "$project_number" ]; then
    log_error "Invalid project $project_name; cannot assign issue to project"
  fi

  log_info "ðŸ“‹ Adding issue #$issue_number to project: $project_name / $project_number"

  issue_url=$(gh issue view "$issue_number" --json url --jq '.url')
  log_info "Issue url: $issue_url"

  gh project item-add "$project_name" --url "$issue_url"
  return 0
}

# Check if issue exists
issue_exists() {
  local issue_number="$1"

  if ! [[ "$issue_number" =~ ^[0-9]+$ ]]; then
    log_error "Issue ID must be a valid issue number"
    return 1
  fi

  gh issue view "$issue_number" >/dev/null 2>&1
}

# Get issue details as JSON
issue_read() {
  local issue_number="$1"
  local include_comments="${2:-false}"

  if ! gh issue view "$issue_number" >/dev/null 2>&1; then
    log_error "Issue #$issue_number does not exist or is not accessible"
  fi

  if [[ "$include_comments" == "true" ]]; then
    gh issue view "$issue_number" --json number,title,body,state,createdAt,updatedAt,author,url,labels,assignees,comments
  else
    gh issue view "$issue_number" --json number,title,body,state,createdAt,updatedAt,author,url,labels,assignees
  fi
}

# Check required dependencies (gh, jq)
validate_dependencies() {
  local missing_deps=()

  if ! command -v gh >/dev/null 2>&1; then
    missing_deps+=("gh (GitHub CLI)")
  fi

  if ! command -v jq >/dev/null 2>&1; then
    missing_deps+=("jq")
  fi

  if ((${#missing_deps[@]} > 0)); then
    error_exit "Missing required dependencies: ${missing_deps[*]}. Please install them and try again."
  fi
}

# Validate GitHub token and auth
validate_token() {
  if [[ -z "${GH_TOKEN:-}" ]]; then
    error_exit "GH_TOKEN not found in environment. Please set it in .env file or environment."
  fi

  export GH_TOKEN

  if ! gh auth status >/dev/null 2>&1; then
    log_info "âš ï¸ gh CLI not authenticated, but GH_TOKEN is available. Proceeding..."
  fi
}

# Get project ID by name (internal helper)
_get_project_number() {
  local project_name="$1"
  local project_owner="$2"

  local owner_args=()

  if [ -n "$project_owner" ]; then
    owner_args+=(--owner "$project_owner")
  fi

  local project_number
  project_number=$(gh project list $owner_args --format json | jq -r ".projects[] | select(.title == \"$project_name\") | .number" 2>/dev/null)

  echo "$project_number"
}
