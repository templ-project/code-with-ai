import { execa } from 'execa';
import fs from 'fs-extra';
import path from 'node:path';
import { concatenateArrays, generateHexColor, paddFeatureId } from './helpers.js';
import { logInfo } from './logger.js';

/**
 * LocalFS Issue Manager
 */

export async function localfsCreateIssue(featureSlug, featureTitle, featureParentDir, featureLabels, featureBody) {
  let featureId;
  
  if (process.env.LOCALFS_FEATURE_ID) {
    featureId = parseInt(process.env.LOCALFS_FEATURE_ID, 10);
  } else {
    const specsFolder = process.env.CWAI_SPECS_FOLDER || 'specs';
    let existingCount = 0;
    
    if (await fs.pathExists(specsFolder)) {
      const entries = await fs.readdir(specsFolder);
      // Count only directories (not files)
      for (const entry of entries) {
        const entryPath = path.join(specsFolder, entry);
        const stat = await fs.stat(entryPath);
        if (stat.isDirectory()) {
          existingCount++;
        }
      }
    }
    
    featureId = existingCount + 1;
  }

  const featurePaddedId = paddFeatureId(featureId);
  const featureDir = path.join(featureParentDir, `${featurePaddedId}-${featureSlug}`);
  await fs.ensureDir(featureDir);

  const now = new Date().toISOString();
  const userName = await getGitUserName();
  const userEmail = await getGitUserEmail();
  const author = `${userName} <${userEmail}>`;
  
  const labelsArray = featureLabels ? featureLabels.split(',').filter(Boolean) : [];

  const issueData = {
    author,
    id: featureId,
    title: featureTitle,
    description: featureBody,
    labels: labelsArray,
    created_at: now,
    updated_at: now,
    comments: []
  };

  await fs.writeJson(path.join(featureDir, 'issue.json'), issueData, { spaces: 2 });
  logInfo(`‚úÖ Created Local issue (#${featureId}) ${featureTitle}`);

  return featureId;
}

export async function localfsUpdateIssue(featureId, featureName, featureDir, featureLabels, featureComment) {
  const issueJsonPath = path.join(featureDir, 'issue.json');
  const issueData = await fs.readJson(issueJsonPath);

  const now = new Date().toISOString();
  const userName = await getGitUserName();
  const userEmail = await getGitUserEmail();
  const author = `${userName} <${userEmail}>`;
  
  const sanitizedComment = featureComment.replace(featureName, '').trim();

  const commentEntry = {
    author,
    comment: sanitizedComment,
    created_at: now
  };

  issueData.comments.push(commentEntry);

  // Update labels
  const existingLabels = issueData.labels.join(',');
  const updatedLabels = concatenateArrays(existingLabels, featureLabels);
  issueData.labels = updatedLabels ? updatedLabels.split(',').filter(Boolean) : [];
  issueData.updated_at = now;

  await fs.writeJson(issueJsonPath, issueData, { spaces: 2 });
  logInfo(`üí¨ Updated Local issue (#${featureId}) ${featureName}`);
}

/**
 * GitHub Issue Manager
 */

export async function githubCreateLabel(labelName, labelColor = '', labelDescription = '') {
  const color = labelColor || generateHexColor();

  try {
    const { stdout } = await execa('gh', ['label', 'list', '--json', 'name', '--jq', '.[].name']);
    const existingLabels = stdout.split('\n').filter(Boolean);
    
    if (existingLabels.includes(labelName)) {
      return;
    }

    logInfo(`üè∑Ô∏è Creating label: ${labelName}`);
    const args = ['label', 'create', labelName, '--color', color];
    if (labelDescription) {
      args.push('--description', labelDescription);
    }
    await execa('gh', args);
  } catch (error) {
    // Silently ignore if gh CLI is not available or label already exists
  }
}

export async function githubCreateIssue(featureSlug, featureTitle, featureParentDir, featureLabels, featureBody) {
  // Ensure required labels exist
  await githubCreateLabel('task', '0e8a16', 'Task item');
  await githubCreateLabel('auto-generated', 'bfd4f2', 'Automatically generated by script');

  const ghLabelArgs = ['--label', 'task', '--label', 'auto-generated'];

  // Create any additional labels
  if (featureLabels) {
    const extraLabels = featureLabels.split(',').filter(Boolean);
    for (const label of extraLabels) {
      await githubCreateLabel(label);
      ghLabelArgs.push('--label', label);
    }
  }

  const { stdout: issueUrl } = await execa('gh', [
    'issue',
    'create',
    '--title',
    featureTitle,
    '--body',
    featureBody,
    ...ghLabelArgs
  ]);

  logInfo(`üè∑Ô∏è Created Github issue: ${issueUrl}`);

  const featureId = parseInt(issueUrl.split('/').pop(), 10);
  process.env.LOCALFS_FEATURE_ID = String(featureId);
  
  await localfsCreateIssue(featureSlug, featureTitle, featureParentDir, featureLabels, featureBody);
  
  delete process.env.LOCALFS_FEATURE_ID;
  return featureId;
}

export async function githubUpdateIssue(featureId, featureName, featureDir, featureLabels, featureComment) {
  const addLabels = [];
  const removeLabels = [];

  if (featureLabels) {
    const labels = featureLabels.split(',').filter(Boolean);
    for (const label of labels) {
      if (label.startsWith('-')) {
        removeLabels.push(label.substring(1));
      } else {
        addLabels.push(label);
        await githubCreateLabel(label);
      }
    }
  }

  if (addLabels.length > 0) {
    await execa('gh', ['issue', 'edit', String(featureId), '--add-label', addLabels.join(',')]);
    logInfo(`üè∑Ô∏è Added labels to issue #${featureId}: ${addLabels.join(', ')}`);
  }

  if (removeLabels.length > 0) {
    await execa('gh', ['issue', 'edit', String(featureId), '--remove-label', removeLabels.join(',')]);
    logInfo(`üè∑Ô∏è Removed labels from issue #${featureId}: ${removeLabels.join(', ')}`);
  }

  await execa('gh', ['issue', 'comment', String(featureId), '--body', featureComment]);
  logInfo(`üí¨ Added comment to Github issue #${featureId}`);

  await localfsUpdateIssue(featureId, featureName, featureDir, featureLabels, featureComment);
}

/**
 * Helper functions
 */

async function getGitUserName() {
  try {
    const { stdout } = await execa('git', ['config', '--get', 'user.name']);
    return stdout.trim();
  } catch {
    return 'Unknown User';
  }
}

async function getGitUserEmail() {
  try {
    const { stdout } = await execa('git', ['config', '--get', 'user.email']);
    return stdout.trim();
  } catch {
    return 'unknown@example.com';
  }
}

/**
 * Issue manager factory
 */

export function getIssueManager(managerType) {
  if (managerType === 'github') {
    return {
      createIssue: githubCreateIssue,
      updateIssue: githubUpdateIssue
    };
  }
  
  return {
    createIssue: localfsCreateIssue,
    updateIssue: localfsUpdateIssue
  };
}
